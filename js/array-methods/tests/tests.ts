// This file is initialized with a few test cases.
// Feel free to add, edit, or remove test cases in
// this file as you see fit!

import chai from "chai"
import spies from "chai-spies"
import "../array-methods"

chai.use(spies)
const spy = <T extends (...args: any[]) => any>(func?: T) => chai.spy(func ?? (() => {}))
const { expect } = chai

describe("array methods", () => {
  describe("myMap", () => {
    describe("on a non-empty array", () => {
      it("calls the passed callback for every element with the correct arguments", () => {
        const array = ["foo", "bar", "baz"]
        const callback = spy()
        array.myMap(callback)

        expect(callback).to.have.been.called.exactly(3)
        expect(callback).on.nth(1).to.be.called.with("foo", 0, array)
        expect(callback).on.nth(2).to.be.called.with("bar", 1, array)
        expect(callback).on.nth(3).to.be.called.with("baz", 2, array)
      })

      it("returns a new array with the results of the passed callback being called on every element", () => {
        const array = [0, 1, 2]
        const callback = (num: number) => num * 2
        const output = array.myMap(callback)

        expect(output).to.be.deep.equal([0, 2, 4])
      })
    })
  })

  describe("myFilter", () => {
    describe("on a non-empty array", () => {
      it("calls the passed callback for every element with the correct arguments", () => {
        const array = ["foo", "bar", "baz"]
        const callback = spy()
        array.myFilter(callback)

        expect(callback).to.have.been.called.exactly(3)
        expect(callback).on.nth(1).to.be.called.with("foo", 0, array)
        expect(callback).on.nth(2).to.be.called.with("bar", 1, array)
        expect(callback).on.nth(3).to.be.called.with("baz", 2, array)
      })

      it("returns a new array containing only the elements that the passed callback returns true for", () => {
        const array = [0, 1, 2, 3, 4, 5]
        const callback = (_: number, i: number) => {
          if (i === 0) return false
          if (i === 1) return true
          if (i === 2) return false
          if (i === 3) return false
          if (i === 4) return false
          if (i === 5) return true
          return false
        }
        const output = array.myFilter(callback)

        expect(output).to.be.deep.equal([1, 5])
      })
    })
  })

  describe("myReduce", () => {
    describe("on a non-empty array", () => {
      describe("when the initialValue is undefined", () => {
        it("calls the passed callback for every element except the first one with the correct arguments", () => {
          const array = [0, 1, 2]
          const callback = spy((sum, currentValue) => sum + currentValue)
          array.myReduce(callback)

          expect(callback).to.have.been.called.exactly(2)
          expect(callback).on.nth(1).to.be.called.with(0, 1, 1, array)
          expect(callback).on.nth(2).to.be.called.with(1, 2, 2, array)
        })
      })

      describe("when the initialValue is defined", () => {
        it("calls the passed callback for every element with the correct arguments", () => {
          const array = [0, 1, 2]
          const callback = spy((sum, currentValue) => sum + currentValue)
          array.myReduce(callback, 0)

          expect(callback).to.have.been.called.exactly(3)
          expect(callback).on.nth(1).to.be.called.with(0, 0, 0, array)
          expect(callback).on.nth(2).to.be.called.with(0, 1, 1, array)
          expect(callback).on.nth(3).to.be.called.with(1, 2, 2, array)
        })
      })

      it("returns the accumulated value generated by the passed callback", () => {
        const array = [0, 1, 2, 3, 4, 5]
        const callback = (sum: number, currentValue: number) => sum + currentValue
        const output = array.myReduce(callback)

        expect(output).to.be.be.equal(15)
      })
    })
  })
})
